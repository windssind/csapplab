## Bomb Lab

### 工具

* objdump 操作数是可执行文件 
* objdump不同参数 -j 指定section -h列出所有的section名称 -d是列出部分的section 而-D是所有的section
* gdb打断点 gdb b *0x400cbc(用于汇编)
* gdb x addr 可以打印出指定地址里面的内容
  * gdb x/<n/f/u> <addr> 例如:gdb x/52c

### Q

1. 汇编代码main之前那一堆东西是干嘛的?
2. 353行代码的意义是什么?上面sub呢?为什么要对栈进行操作?
3. 925行?
4. 汇编代码是不是没有显示出数据区?还有库函数区?
5. 402400这些,应该是存储的数据区,包含着答案.那为什么我的402400没有东西?

### 笔记

* X86采用的是小端法,所以0X12345678 存储(地址从小到大)78 56 34 12,书写习惯是0X12345678
* 所以mov 0X12345678这个数字到64位的REG中,REG存储的是78 56 34 12,%al应该是12.因为0X12345678在计算机中的存储是小端法



### Phase 1

* 通过gdb调试,得知密码长度为52,那么可以通过x命令来获取对应区间的字符了
*  66 'B'  111 'o' 114 'r' 100 'd' 101 'e' 114 'r' 32 ' '  114 'r'
  0x402408:       101 'e' 108 'l' 97 'a'  116 't' 105 'i' 111 'o' 110 'n' 115 's'
  0x402410:       32 ' '  119 'w' 105 'i' 116 't' 104 'h' 32 ' '  67 'C'  97 'a'
  0x402418:       110 'n' 97 'a'  100 'd' 97 'a'  32 ' '  104 'h' 97 'a'  118 'v'
  0x402420:       101 'e' 32 ' '  110 'n' 101 'e' 118 'v' 101 'e' 114 'r' 32 ' '
  0x402428:       98 'b'  101 'e' 101 'e' 110 'n' 32 ' '  98 'b'  101 'e' 116 't'
  0x402430:       116 't' 101 'e' 114 'r' 46 '.'
* 答案: Border relations with Canada have never been better.

### Phase2

* 有个疑问:栈不是八个字节的吗,如果是四个字节,pushw就很怪,虽然也是栈,但是这个栈的不同高度的底不是相同的

* 答案:1 2 4 8 16 32

* i r指令可以看寄存器的值  p 后面带参数可以按指定的格式输出

* ```asm
   400efc:	55                   	push   %rbp
    400efd:	53                   	push   %rbx
    400efe:	48 83 ec 28          	sub    $0x28,%rsp # 六个数字和两个保存寄存器
    # sub两个push占用两个8字节,剩下的六个int为4字节
  ```

  

### Phase3

* 为什么栈要减去18?
* scanf将数据存储在栈的什么位置?

### Phase4

* SAR指令,当只有一个操作数时,默认为1
* 算数右移无法理解为什么叫算术右移?1011右移一个1101嗯?有什么用呢?
* 嗯?给我感觉很怪

### Phase5

* 内存中,未被操作初始化的字节默认为0 

* 查看栈顶元素 x $rsp

* 我的p /t $rdx只打印出1101000,为什么只有七位

  如果你使用p /t $rdx命令只能打印出7位二进制数，而不是期望的64位二进制数，这可能是因为GDB默认只显示一个整数类型的最低有效位（LSB）到最高有效位（MSB）的第一个非零位之间的位数

* Q:

* 40108b:	0f b6 0c 03          	movzbl (%rbx,%rax,1),%ecx
    40108f:	88 0c 24             	mov    %cl,(%rsp)
    401092:	48 8b 14 24          	mov    (%rsp),%rdx # 有个疑问，寄存器也遵循大端法小端法吗
    401096:	83 e2 0f             	and    $0xf,%edx  # 只保留rdx最右边的四个位置，其他全部为0

* 已知道%rbx中开始存储的是字符h,ecx会被更新为0x00000068,下一步,再下一步,rsp指向的区域会被更新为0x68000000000,然后rdx也是0x68000000,再把edx给and掉,为什么edx会变为5?

* 对大端法和小端法的理解!! **大端法或小端法是数据在存储时的表现，而不是在寄存器中参与运算时的表现**。

* 而mov指令是无关大小端法的



### Phase 6

* 关键是结点该如何理解,要看出这一步,然后循环体也要看出来,哪一些是初始化条件,哪一些是函数执行体
* 理解指令的操作位数,